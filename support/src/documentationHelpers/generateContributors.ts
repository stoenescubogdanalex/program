/**
 * Update contributors.md based on github users who have commits in the repo.
 *
 * Note that this code was mostly generated by AI.
 *
 * Usage:
 *   npm run generate:contributors
 */

import * as fs from "node:fs/promises";

import { Octokit } from "octokit";
const listContributors = (o: Octokit) =>
  o.request("GET /repos/{owner}/{repo}/contributors");
type Contributor = Awaited<ReturnType<typeof listContributors>>["data"][number];

const fetch = global.fetch;

// ---------------- CONFIG ----------------
const REPO = "HackYourFuture-CPH/program";
const PER_ROW = 6;
const AVATAR_SIZE = 80;
const EXCLUDE_LOGINS: string[] = [];
// ----------------------------------------

const API_BASE = "https://api.github.com";

function parseLinkHeader(link: string | null): Record<string, string> {
  const rels: Record<string, string> = {};
  if (!link) return rels;
  link.split(",").forEach((part) => {
    const section = part.split(";");
    if (section.length !== 2) return;
    const url = section[0].trim().replace(/^<|>$/g, "");
    const name = section[1].trim().replace(/rel="(.*)"/, "$1");
    rels[name] = url;
  });
  return rels;
}

async function fetchPaginated<T>(url: string): Promise<T[]> {
  let results: T[] = [];
  let next: string | null = url;
  while (next) {
    const res = await fetch(next, {
      headers: { "User-Agent": "contributors-script" },
    });
    if (!res.ok) {
      throw new Error(
        `GitHub API error ${res.status} ${res.statusText} for ${next}`,
      );
    }
    const page = (await res.json()) as T[];
    results = results.concat(page);
    const link = res.headers.get("link");
    const rels = parseLinkHeader(link);
    next = rels.next || null;
  }
  return results;
}

function isBotLogin(login: string): boolean {
  if (!login) return false;
  return (
    login.toLowerCase().endsWith("[bot]") ||
    login.toLowerCase().includes("-bot") ||
    login.toLowerCase().includes("bot/")
  );
}

function withAvatarSize(url: string, size: number): string {
  if (!url) return url;
  return url + (url.includes("?") ? `&s=${size}` : `?s=${size}`);
}

function chunk<T>(array: readonly T[], size: number): T[][] {
  const chunks = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

async function fetchContributors(repo: string): Promise<Contributor[]> {
  const url = `${API_BASE}/repos/${repo}/contributors?per_page=100&anon=false`;
  const data = await fetchPaginated<Contributor>(url);
  return data
    .map((c) => ({
      login: c.login,
      html_url: c.html_url || `https://github.com/${c.login}`,
      avatar_url: c.avatar_url,
      contributions: c.contributions || 0,
      type: c.type || "User",
    }))
    .filter((c) => !!c.login);
}

function filterAndSortContributors(
  items: readonly Contributor[],
): Contributor[] {
  let list = items.filter((c) => {
    const excluded =
      EXCLUDE_LOGINS.includes(c.login!.toLowerCase()) || isBotLogin(c.login!);
    const isUser = (c.type || "User") === "User";
    return isUser && !excluded;
  });

  // sort by most commits and then alphabetically if a tie
  list.sort((a, b) => {
    const byContrib = (b.contributions || 0) - (a.contributions || 0);
    if (byContrib !== 0) return byContrib;
    return a.login!.localeCompare(b.login!, "en");
  });

  return list;
}

function renderMarkdown(contributors: readonly Contributor[]): string {
  const date = new Date().toISOString().split("T")[0];
  const total = contributors.length;

  let out = `
Total: **${total}** contributor${total === 1 ? "" : "s"}

`;

  if (total === 0) {
    out += "_No contributors found (after filtering)._";
    return out;
  }

  // Chunk into rows
  const rows = chunk(contributors, PER_ROW);

  // First row: avatars
  rows.forEach((row) => {
    const avatarCells = row.map(
      (c) =>
        `[![${c.login}](${withAvatarSize(
          c.avatar_url!,
          AVATAR_SIZE,
        )})](${c.html_url})`,
    );
    const sep = row.map(() => "---");
    const nameCells = row.map((c) => `[@${c.login}](${c.html_url})`);

    out += `| ${avatarCells.join(" | ")} |\n`;
    out += `| ${sep.join(" | ")} |\n`;
    out += `| ${nameCells.join(" | ")} |\n\n`;
  });

  return out;
}

async function updateFileSection(
  contentToInsert: string,
  filename: string,
): Promise<void> {
  const oldContent = await fs.readFile(filename, "utf-8");

  const matches = [
    ...oldContent.matchAll(
      /(<!-- BEGIN generateContributors -->).*?(<!-- END generateContributors -->)/gs,
    ),
  ];

  if (matches.length !== 1)
    throw new Error(
      `Expected to find 1 BEGIN/END pair, found ${matches.length}`,
    );

  const newContent = [
    oldContent.substring(0, matches[0].index),
    matches[0][1],
    `\n\n${contentToInsert.trim()}\n\n`,
    matches[0][2],
    oldContent.substring(matches[0].index + matches[0][0].length),
  ].join("");

  if (newContent === oldContent) {
    console.log(`${filename} is already up-to-date, no changes made`);
  } else {
    const tmpFile = filename + ".tmp";
    await fs.unlink(tmpFile).catch(() => undefined);
    await fs.writeFile(tmpFile, newContent, "utf-8");
    await fs.rename(tmpFile, filename);
    console.log(`${filename} updated`);
  }
}

async function main() {
  try {
    const raw = await fetchContributors(REPO);
    const contributors = filterAndSortContributors(raw);
    const md = renderMarkdown(contributors);
    await updateFileSection(md, "./contributing/contributors.md");
  } catch (err: any) {
    console.error("Error:", err.message);
    process.exit(1);
  }
}

main();
