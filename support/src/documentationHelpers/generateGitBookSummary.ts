#!/usr/bin/env node
/**
 * Generate GitBook SUMMARY.md markdown based on programStructure.json.
 * It outputs to the command line.
 * Only copy the markdown that you need, since we make some manual edits in SUMMARY.md that should not be overwritten.
 * This script should probably accept an argument to only generate code for a specific course/module in the future.
 *
 * Note that this code was mostly generated by AI.
 *
 * Usage:
 *   npm run generate:gitbook-summary
 */

import fs, { type Dirent } from "fs";
import path from "path";
import process from "process";

import programStructure from "./programStructure.json" with { type: "json" };
import type { ProgramStructure } from "./programStructure.js";

let rootDir = process.cwd();
let debug = false;

// ---------------- Helpers ----------------
const toPosix = (p: string): string => p.split(path.sep).join("/");
const posixJoin = (...parts: readonly string[]): string =>
  toPosix(path.join(...parts));
const toPosixFromRoot = (absPath: string): string => {
  const rel = path.relative(rootDir, absPath);
  return rel ? toPosix(rel) : ".";
};

const exists = (p: string): boolean => {
  try {
    fs.accessSync(p, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
};

const listDirents = (dir: string): Dirent[] =>
  exists(dir) ? fs.readdirSync(dir, { withFileTypes: true }) : [];
const listDirs = (dir: string): string[] =>
  listDirents(dir)
    .filter((d) => d.isDirectory())
    .map((d) => d.name);
const listFiles = (dir: string): string[] =>
  listDirents(dir)
    .filter((d) => d.isFile())
    .map((d) => d.name);

function ensureReadmeLink(baseAbsDir: string, relPosix: string): string {
  const candidate = path.join(baseAbsDir, "README.md");
  if (exists(candidate)) return posixJoin(relPosix, "README.md");
  return relPosix;
}

// Case-insensitive resolver
function resolveCaseInsensitive(absDir: string, wanted: string): string | null {
  const exact = path.join(absDir, wanted);
  if (exists(exact)) return wanted;
  const files = listFiles(absDir);
  const lowerWanted = wanted.toLowerCase();
  const found = files.find((f) => f.toLowerCase() === lowerWanted);
  return found || null;
}

const WEEK_RE = /^week(\d+)$/i;
const weekNumber = (name: string): number | null => {
  const m = WEEK_RE.exec(name);
  return m ? parseInt(m[1], 10) : null;
};

const indent = (level: number): string => "  ".repeat(level);
const linkLine = (level: number, text: string, filePath: string): string =>
  `${indent(level)}- ${filePath ? `[${text}](${filePath})` : text}`;

// ---------------- Core ----------------
function generateSummary(structure: ProgramStructure, rootDir: string): string {
  const lines = [];

  for (const course of structure.courses) {
    const courseAbs = path.resolve(rootDir, course.location);
    const courseRel = toPosixFromRoot(courseAbs);
    if (debug)
      console.error(
        `[debug] course="${course.name}" dir=${courseAbs} exists=${exists(courseAbs)}`,
      );
    const courseLink = ensureReadmeLink(courseAbs, courseRel);
    lines.push(linkLine(0, course.name, courseLink));

    for (const module of course.modules) {
      const modAbs = path.resolve(rootDir, module.location);
      const modRel = toPosixFromRoot(modAbs);
      if (debug)
        console.error(
          `  [debug] module="${module.name}" dir=${modAbs} exists=${exists(modAbs)}`,
        );
      const modLink = ensureReadmeLink(modAbs, modRel);
      lines.push(linkLine(1, module.name, modLink));

      // discover week folders
      const weekFolders = listDirs(modAbs)
        .map((d) => ({ name: d, num: weekNumber(d) }))
        .filter((w): w is { name: string; num: number } => w.num !== null)
        .sort((a, b) => a.num - b.num);

      if (debug)
        console.error(
          `    [debug] weeks=${weekFolders.map((w) => w.name).join(", ") || "(none)"}`,
        );

      if (weekFolders.length > 0) {
        for (const w of weekFolders) {
          const weekAbs = path.join(modAbs, w.name);
          const weekRel = toPosixFromRoot(weekAbs);
          const weekTitle = `Week ${w.num}`;
          const weekLink = ensureReadmeLink(weekAbs, weekRel);
          lines.push(linkLine(2, weekTitle, weekLink));

          const files = [
            { title: "Preparation", file: "preparation.md" },
            { title: "Session Plan", file: "session-plan.md" },
            { title: "Assignment", file: "assignment.md" },
          ];

          for (const f of files) {
            const resolved = resolveCaseInsensitive(weekAbs, f.file);
            if (resolved) {
              const relF = posixJoin(weekRel, resolved);
              lines.push(linkLine(3, f.title, relF));
            } else if (debug) {
              console.error(
                `      [debug] missing file ${path.join(weekAbs, f.file)}`,
              );
            }
          }
        }
      } else {
        // fallback: no week dirs â†’ check module root for session files
        const files = [
          { title: "Preparation", file: "preparation.md" },
          { title: "Session Plan", file: "session-plan.md" },
          { title: "Assignment", file: "assignment.md" },
        ];

        for (const f of files) {
          const resolved = resolveCaseInsensitive(modAbs, f.file);
          if (resolved) {
            const relF = posixJoin(modRel, resolved);
            lines.push(linkLine(2, f.title, relF));
          } else if (debug) {
            console.error(
              `    [debug] missing module-root file ${path.join(modAbs, f.file)}`,
            );
          }
        }
      }
    }
  }

  return lines.join("\n") + "\n";
}

// ---------------- Run ----------------
try {
  const md = generateSummary(programStructure as ProgramStructure, rootDir);

  process.stdout.write(md);
} catch (err: any) {
  console.error("Error:", err.message);
  process.exit(1);
}
